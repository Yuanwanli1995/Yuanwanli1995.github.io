<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yuanwanli1995.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/./public/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="等不是办法，干才有出路">
<meta property="og:type" content="website">
<meta property="og:title" content="brisk">
<meta property="og:url" content="http://yuanwanli1995.github.io/page/7/index.html">
<meta property="og:site_name" content="brisk">
<meta property="og:description" content="等不是办法，干才有出路">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuanwanli">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yuanwanli1995.github.io/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>brisk</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">brisk</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">welcome</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuanwanli</p>
  <div class="site-description" itemprop="description">等不是办法，干才有出路</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/16/2021-11-16-kubepray-%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/16/2021-11-16-kubepray-%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">kubepray 搭建集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-16T00:00:00+08:00">2021-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1 环境准备"></a>1 环境准备</h1><p>1）所以的主机都需要关闭selinux，执行的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0``sed -i --follow-symlinks ``&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;` `/etc/sysconfig/selinux</span><br></pre></td></tr></table></figure>

<p>2）防火墙（可选）和网络设置，所有的主机都执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp; systemctl disable firewalld``modprobe br_netfilter``echo ``&#x27;1&#x27;` `&gt; /proc/sys/net/bridge/bridge-nf-call-iptables``sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>

<p>3）#设置内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/security/limits.conf``* soft nofile 32768``* hard nofile 65535``* soft nproc 32768``* hadr nproc 65535</span><br></pre></td></tr></table></figure>

<p>4）设置k8s内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.d/k8s.conf``net.bridge.bridge-nf-call-ip6tables = 1``net.bridge.bridge-nf-call-iptables = 1``net.ipv4.ip_nonlocal_bind = 1``net.ipv4.ip_forward = 1``vm.swappiness=0</span><br></pre></td></tr></table></figure>

<p>5）重新加载生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl --system``sudo sysctl -p</span><br></pre></td></tr></table></figure>

<p>\6) 安装 python 及 epel (<strong>在Ansible主机上安装并配置好与各node的免秘钥登录)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release python36 python36-pip git</span><br><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id rancher@192.168.2.51</span><br><span class="line">ssh-copy-id rancher@192.168.2.52</span><br><span class="line">ssh-copy-id rancher@192.168.2.53</span><br></pre></td></tr></table></figure>



<h1 id="2-部署k8s集群"><a href="#2-部署k8s集群" class="headerlink" title="2 部署k8s集群"></a>2 部署k8s集群</h1><p>1）#克隆项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:``//github.com/kubernetes-sigs/kubespray/archive/v2.12.4.tar.gz </span><br><span class="line">tar -zxf v2.12.4.tar.gz </span><br></pre></td></tr></table></figure>

<p>2）# Install dependencies from <code>requirements.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/pip3.6 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>3）# Copy <code>inventory/sample</code> as <code>inventory/mycluster</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rfp inventory/sample inventory/mycluster</span><br></pre></td></tr></table></figure>

<p>4）# Update Ansible inventory file with inventory builder</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -a IPS=(10.10.1.3 10.10.1.4 10.10.1.5)`CONFIG_FILE=inventory/mycluster/hosts.yaml /usr/bin/python3.6 contrib/inventory_builder/inventory.py $&#123;IPS[@]&#125;</span><br></pre></td></tr></table></figure>

<p>5）# Review and change parameters under <code>inventory/mycluster/group_vars</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat inventory/mycluster/group_vars/all/all.yml` `cat inventory/mycluster/group_vars/k8s-cluster/k8s-cluster.yml</span><br></pre></td></tr></table></figure>

<p>6）# Deploy Kubespray with Ansible Playbook - run the playbook as root</p>
<p># The option <code>--become</code> is required, as for example writing SSL keys in /etc/,</p>
<p># installing packages and interacting with various systemd daemons.</p>
<p># Without –become the playbook will fail to run!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i inventory/mycluster/hosts.yaml --become --become-user=root cluster.yml</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/15/2021-11-15-vim%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/15/2021-11-15-vim%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">vim进阶使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-15T00:00:00+08:00">2021-11-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>用了一段时间vim感觉其确实是很强的编辑器，前提是熟悉vim的使用。如果只会切换模式、输入，可能vim感觉并不是很好用，所以说vim入门难。从我的使用经验来看，vim的灵活性上限很高，想要融汇贯通，随心输入，必须先熟悉基本的操作，然后在每次使用vim的时候，任何操作，即使是简单的操作也要求自己使用最方便的方法，不知道可以去查，然后记录并多多练习，开始一段时间按会很痛苦，但是会进步很快。为了系统地掌握vim的命令，加深记忆并方便查找，这里总结vim用法。</p>
<h3 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1 光标移动"></a>1 光标移动</h3><h4 id="1-1-最小的移动单元"><a href="#1-1-最小的移动单元" class="headerlink" title="1.1 最小的移动单元"></a>1.1 最小的移动单元</h4><ul>
<li>h 左 </li>
<li>j 下</li>
<li>k 上</li>
<li>l 右</li>
</ul>
<p>不是很好记，但用的多了就熟悉了，总的来说hjkl四个键可移动光标，左边的h就是向左，右边l向右。j像一个向下钩子，为向下。剩下的k向上。</p>
<h4 id="1-2-以单词为单位的光标移动"><a href="#1-2-以单词为单位的光标移动" class="headerlink" title="1.2 以单词为单位的光标移动"></a>1.2 以单词为单位的光标移动</h4><p>w， W向右移动到下一个单词开头。</p>
<p>e,    E向右移动到单词结尾 。</p>
<p>b,   B向左移动到单词开头。</p>
<h4 id="1-3-更大的移动方法"><a href="#1-3-更大的移动方法" class="headerlink" title="1.3 更大的移动方法"></a>1.3 更大的移动方法</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/14/2021-11-14-k8s%E9%83%A8%E7%BD%B2%E5%B0%8F%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/14/2021-11-14-k8s%E9%83%A8%E7%BD%B2%E5%B0%8F%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">k8s部署小游戏</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-14T00:00:00+08:00">2021-11-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="k8s部署小游戏"><a href="#k8s部署小游戏" class="headerlink" title="k8s部署小游戏"></a>k8s部署小游戏</h3><p>k8s部署小游戏非常简单，比js前端部署方便多了。下面试一试玩一玩<br><code>1 查看镜像</code><br>docker hub里已经有其他人上传的游戏镜像了，我们可以直接拿来用，这就是镜像仓库的优势，可以直接使用别人造好的轮子。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node02 ~]# docker search 2048 </span><br><span class="line">NAME                    DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">quchaonet/2048          项目:[2048游戏]-一个经典的网页小游戏-镜像定…                     6                                       </span><br><span class="line">blackicebird/2048       2048 with logging                               4                                       </span><br><span class="line">amigoscode/2048                                                         1                                       </span><br><span class="line">ponsfrilus/2048nginx    A nginx containter wich run 2048                1                                       [OK]</span><br></pre></td></tr></table></figure>
<p><code>2 部署pod</code><br>使用k8s编排容器，部署一个deploy, 还能高可用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; game-deploy.yaml &lt;&lt; EOF </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: game-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: game</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: game</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: game</span><br><span class="line">        image: blackicebird/2048</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">EOF</span><br><span class="line"># 刚才查到的star多的镜像写上去  </span><br><span class="line">kubectl create -f game-deploy.yaml</span><br></pre></td></tr></table></figure>
<p><code>部署路由，外部访问</code><br>起一个loadbalancer服务，让客户端可以访问到pod, 注意标签对应deploy的标签， targetPort端口是pod的端口.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; game-loadbalancer.yaml &lt;&lt; EOF </span><br><span class="line">apiVersion: v1 </span><br><span class="line">kind: Service</span><br><span class="line">metadata: </span><br><span class="line">  name: game-loadbalancer</span><br><span class="line">spec: </span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports: </span><br><span class="line">  - port: 80 </span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector: </span><br><span class="line">    app: game</span><br><span class="line">EOF</span><br><span class="line"># 启动</span><br><span class="line">kubectl create -f game-loadbalancer.yaml</span><br></pre></td></tr></table></figure>
<p><code>查看</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node02 ~]# kubectl get po </span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">game-deployment-84bf68885d-bwctb   1/1     Running   0          21m</span><br><span class="line">game-deployment-84bf68885d-j9qq9   1/1     Running   0          21m</span><br><span class="line">[root@k8s-node02 ~]# kubectl get svc </span><br><span class="line">NAME                TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)        AGE</span><br><span class="line">game-loadbalancer   LoadBalancer   192.168.0.117   175.27.183.90   80:31382/TCP   18m</span><br><span class="line">kubernetes          ClusterIP      192.168.0.1     &lt;none&gt;          443/TCP        9d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>访问</code></p>
<p>打开游览器, EXTERNAL-IP:<port></p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/2048-.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/12/2021-11-12-%E4%BB%80%E4%B9%88%E6%98%AFserverless/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/12/2021-11-12-%E4%BB%80%E4%B9%88%E6%98%AFserverless/" class="post-title-link" itemprop="url">什么是serverless</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-12T00:00:00+08:00">2021-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是severless"><a href="#1-什么是severless" class="headerlink" title="1 什么是severless ?"></a>1 什么是severless ?</h1><p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%91%E5%B1%95.png"></p>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用[serverless handbook](<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/serverless-handbook/concepts-what-is-serverless.md">什么是 Serverless - Serverless 的定义 - 《无服务架构实践手册（Serverless Handbook）》 - 书栈网 · BookStack</a>)给出通俗易懂和具体的定义。</p>
<ul>
<li> 简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li> <strong>进阶定义</strong>:  Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。</li>
</ul>
<blockquote>
<p> 就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</p>
</blockquote>
<h1 id="2-有服务到无服务构架有哪些变化？"><a href="#2-有服务到无服务构架有哪些变化？" class="headerlink" title="2 有服务到无服务构架有哪些变化？"></a>2 有服务到无服务构架有哪些变化？</h1><ol>
<li><strong>弱化了存储和计算之间的联系。</strong>服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>
<li><strong>代码的执行不再需要手动分配资源。</strong>不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>
<li><strong>按使用量计费。</strong>Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。</li>
</ol>
<p>云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？<strong>让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</strong></p>
<h1 id="3-serverless发展历史"><a href="#3-serverless发展历史" class="headerlink" title="3 serverless发展历史"></a>3 serverless发展历史</h1><p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>
<ul>
<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。<strong>就比如我们用的水和电一样</strong>，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。 </li>
<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>
<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a target="_blank" rel="noopener" href="https://iron.io/">iron.io</a>。</li>
<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>
</ul>
<h1 id="4-severless-分类"><a href="#4-severless-分类" class="headerlink" title="4 severless 分类"></a>4 severless 分类</h1><p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。 </p>
<ul>
<li><p>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</p>
</li>
<li><p>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</p>
</li>
</ul>
<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>
<h1 id="5-severles优缺点"><a href="#5-severles优缺点" class="headerlink" title="5 severles优缺点"></a>5 severles优缺点</h1><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li><p> 降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</p>
</li>
<li><p>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</p>
</li>
<li><p>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</p>
</li>
<li><p>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</p>
</li>
<li><p>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</p>
<p>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是<strong>多快好省</strong>。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</p>
</li>
<li><p>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</p>
</li>
<li><p>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</p>
</li>
<li><p>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</p>
</li>
<li><p>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</p>
</li>
<li><p>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</p>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li> 状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>
<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>
<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>
</ul>
<h1 id="5-serverless使用场景"><a href="#5-serverless使用场景" class="headerlink" title="5 serverless使用场景"></a>5 serverless使用场景</h1><p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。 </p>
<ul>
<li>异步的并发，组件可独立部署和扩展</li>
<li>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</li>
<li>短暂、无状态的应用，对冷启动时间不敏感</li>
<li>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）</li>
</ul>
<p>Serverless 的使用场景示例如：</p>
<ul>
<li>ETL</li>
<li>机器学习及 AI 模型处理</li>
<li>图片处理</li>
<li>IoT 传感器数据分析</li>
<li>流处理</li>
<li>聊天机器人</li>
</ul>
<p>示例： </p>
<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>
<p>一款移动端游戏至少包含如下几个特性：</p>
<ul>
<li>移动端友好的用户体验</li>
<li>用户管理和权限认证</li>
<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息</li>
</ul>
<p>传统的应用程序架构可能是这样的：</p>
<p><img src="https://static.sitestack.cn/projects/serverless-handbook/aa9eaf9b461ca39ea6b4bf01fc5f129b.jpeg" alt="传统应用程序架构"></p>
<ul>
<li>一个 app 前端，iOS 或者安卓</li>
<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>
<li>使用关系型数据库存储用户数据，如 MySQL</li>
</ul>
<p>这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</p>
<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>
<p><img src="https://static.sitestack.cn/projects/serverless-handbook/37377bea471dae7039d9335f7b232a8e.jpeg" alt="Serverless 架构"></p>
<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>
<h1 id="6-serverless核心技术"><a href="#6-serverless核心技术" class="headerlink" title="6 serverless核心技术"></a>6 serverless核心技术</h1><p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>
<ul>
<li>函数的规范定义</li>
<li>函数部署流水线</li>
<li>Workflow 设置</li>
<li>0-m-n 扩缩容</li>
<li>快速冷启动</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>
<blockquote>
<p>参考文献： severless handbook </p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/11/2021-11-12-openfaas-v0.2%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/11/2021-11-12-openfaas-v0.2%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">openfaas v0.2文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-11T00:00:00+08:00">2021-11-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="openfass-让无服务变得简单"><a href="#openfass-让无服务变得简单" class="headerlink" title="openfass  让无服务变得简单"></a>openfass  让无服务变得简单</h3><p>OpenFaaS®使开发人员可以轻松地将事件驱动函数和微服务部署到Kubernetes，而无需重复的模板代码。将您的代码或现有二进制文件打包到Docker镜像中，以获得具有自动伸缩和度量的高度可伸缩端点。</p>
<h3 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h3><ul>
<li>开源函数框架-在任何云上运行它，无需担心锁定</li>
<li>编写任何语言的函数，并将它们打包到Docker/ oci格式的容器中</li>
<li>易于使用的内置UI，强大的CLI和一键式安装</li>
<li>处理流量峰值，并在空闲时进行伸缩</li>
<li>活跃的社区-贡献和归属</li>
</ul>
<h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><p>pass</p>
<h2 id="社群"><a href="#社群" class="headerlink" title="社群"></a>社群</h2><p>pass</p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>OpenFaaS可以部署到Kubernetes、OpenShift、Docker Swarm等多种容器管理工具上，也可以部署到使用faasd的单个主机上。</p>
<p>Kubernetes还是faasd ?</p>
<p>我们建议在工作中使用OpenFaaS时使用Kubernetes或OpenShift，因为它可以很好地扩展，如果您需要，OpenFaaS Ltd可以提供商业支持。一些公司已经在生产中使用了Faasd，但您应该了解其中的权衡。用户以后可以在这两种部署选项之间切换。</p>
<h2 id="PLONK-Stack"><a href="#PLONK-Stack" class="headerlink" title="PLONK Stack"></a>PLONK Stack</h2><p>PLONK是一个用于构建应用程序的云本地堆栈，它代表:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/d41d8cd98f00b204.md">Prometheus</a>-度量和时间序列</p>
</li>
<li><p>Linux/Linkerd* - OS或service mesh (Linkerd是可选的)</p>
</li>
<li><p>OpenFaaS——计算的管理和自动扩展——PaaS/FaaS, Kubernetes之上的一个开发人员友好的抽象。每个函数或微服务都构建为不可变的Docker容器或oci格式的镜像。</p>
</li>
<li><p>异步消息总线/队列</p>
</li>
<li><p>Kubernetes -声明式的、可扩展的、伸缩的、自修复的集群</p>
</li>
</ul>
<p>Kubernetes上的OpenFaaS包了NATS和Prometheus。您可以在OpenFaaS架构文档中阅读有关堆栈的内容。</p>
<h2 id="Kubernetes-推荐用于生产和工作"><a href="#Kubernetes-推荐用于生产和工作" class="headerlink" title="Kubernetes(推荐用于生产和工作)"></a>Kubernetes(推荐用于生产和工作)</h2><p>关于安全的前言</p>
<p>默认情况下，使用OpenFaaS启用身份验证，但是如果您在公共Internet上使用OpenFaaS，您还需要为您的集群获取TLS证书。免费证书可从LetsEncrypt.org获得。</p>
<p>在Kubernetes集群中安装OpenFaaS有三种推荐方法:</p>
<ul>
<li>使用我们的CLI安装程序arkade -(推荐)</li>
<li>使用Helm chart, Flux或ArgoCD (GitOps工作流)</li>
<li>或者使用静态生成的YAML文件(不推荐)</li>
</ul>
<p>了解关于每个选项以及如何将OpenFaaS部署到Kubernetes的更多信息:<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/34026a917156630f.md">Deploy to Kubernetes</a></p>
<h2 id="faasd-每个人的无服务"><a href="#faasd-每个人的无服务" class="headerlink" title="faasd - 每个人的无服务"></a>faasd - 每个人的无服务</h2><p>faasd是OpenFaaS，没有Kubernetes的复杂性和成本。它在要求非常低的单个主机上运行良好，可以在几分钟内部署。在内部，它使用容器和容器网络接口(CNI)以及来自主项目的相同核心OpenFaaS组件。</p>
<p>什么时候应该在Kubernetes上使用faasd over OpenFaaS ?</p>
<ul>
<li>你有一个成本敏感的项目-运行faasd在5-10美元的VPS或在你的Raspberry Pi上</li>
<li>当您只需要一些功能或微服务，而不需要集群的成本时</li>
<li>当你没有时间学习或管理Kubernetes的时候</li>
<li>在物联网和边缘用例中部署嵌入式应用</li>
<li>将应用程序压缩包装以供客户或客户使用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/openfaas/faasd/">Deploy faasd</a></p>
<h2 id="OpenShift"><a href="#OpenShift" class="headerlink" title="OpenShift"></a>OpenShift</h2><p>OpenShift是由RedHat生产的Kubernetes的一个变体。</p>
<p>您可以使用我们的CLI安装程序<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/d41d8cd98f00b204.md">arkade</a> 或标准helm chart部署到OpenShift。</p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/f81fd004e195cc7a.md">Deploy to OpenShift</a></p>
<h2 id="Docker-Swarm-弃用"><a href="#Docker-Swarm-弃用" class="headerlink" title="Docker Swarm (弃用)"></a>Docker Swarm (弃用)</h2><p>取消免费社区支持，Docker Swarm的免费社区支持已经停止。如果您在业务中运行Docker Swarm和OpenFaaS，并且需要持续的支持，那么请尽快联系支持人员。</p>
<p>为什么做出这个决定?Docker Swarm被广泛认为是“生命终结”产品。像Kubernetes这样的项目拥有更广泛的生态系统，并不断从各自的社区获得投资。</p>
<p>如果你被Docker Swarm所吸引是因为你认为它比Kubernetes更容易管理，我们建议你看看托管的Kubernetes服务，或 <a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/d41d8cd98f00b204.md">k3s.io</a>.</p>
<p>如果你几乎不需要任何操作，那么faasd(上面)应该是你的首选。</p>
<h1 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>您可以使用curl实用程序脚本、brew或从发布页面下载二进制文件来安装CLI。安装完成后，您将获得faas-cli命令和faas别名。</p>
<h3 id="Linux-or-macOS"><a href="#Linux-or-macOS" class="headerlink" title="Linux or macOS"></a>Linux or macOS</h3><p>使用curl脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://cli.openfaas.com | sudo -E sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>标志-E允许将任何http_proxy环境变量传递给安装bash脚本。</p>
</blockquote>
<p>使用curl将二进制文件下载到当前目录，然后打印安装说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://cli.openfaas.com | sh</span><br></pre></td></tr></table></figure>

<p>通过 brew</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install faas-cli</span><br></pre></td></tr></table></figure>

<p>注意, brew版本可能不会运行最新的小版本，但会定期更新。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在powershell中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$version = (Invoke-WebRequest &quot;https://api.github.com/repos/openfaas/faas-cli/releases/latest&quot; | ConvertFrom-Json)[0].tag_name</span><br><span class="line">(New-Object System.Net.WebClient).DownloadFile(&quot;https://github.com/openfaas/faas-cli/releases/download/$version/faas-cli.exe&quot;, &quot;faas-cli.exe&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="覆盖环境变量"><a href="#覆盖环境变量" class="headerlink" title="覆盖环境变量"></a>覆盖环境变量</h3><p>如果set和没有设置其他命令行标志，将默认使用几个覆盖。</p>
<ul>
<li><code>OPENFAAS_TEMPLATE_URL</code> -设置获取模板的默认URL</li>
<li><code>OPENFAAS_PREFIX</code> - 当使用 <code>faas-cli new</code> - 这可以替代 <code>--prefix</code></li>
<li><code>OPENFAAS_URL</code> -来覆盖默认网关URL</li>
</ul>
<h3 id="使用sudo运行-faas-cli"><a href="#使用sudo运行-faas-cli" class="headerlink" title="使用sudo运行 faas-cli"></a>使用sudo运行 <code>faas-cli</code></h3><p>如果您使用sudo运行faas-cli，我们建议使用sudo -E来传递您可能配置的任何环境变量，如http_proxy、https_proxy或no_proxy。</p>
<h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>faas-cli还可以作为Docker镜像使用，这使得它可以方便地用于CI作业，如使用Jenkins管道或cron中的任务。</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/r/openfaas/faas-cli/tags/">https://hub.docker.com/r/openfaas/faas-cli/tags/</a></p>
<p>它没有“latest”标签，请在Docker Hub的标签页中找到您想要使用的CLI版本。这些对应于GitHub的发布。</p>
<blockquote>
<p>注意:Docker映像不能用于直接执行构建，但你可以使用它来生成一个构建上下文，可以与容器构建器(如Docker, buildkit或Kaniko)在构建管道的另一部分一起使用。</p>
</blockquote>
<p>Docker映像的用例:</p>
<ul>
<li>不运行docker build - faas-cli——shrinkwrap来生成构建上下文</li>
<li>将现有映像部署到远程服务器faas-cli Deploy</li>
<li>使用faas-cli secret管理秘密</li>
<li>通过使用faas-cli调用cron调用函数</li>
<li>使用faas-cli信息检查远程网关的运行状况</li>
</ul>
<h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><p>该<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/742c32d44c647dc9.md#contribute">指南</a>提供了从源代码构建和配置Golang开发环境的说明。</p>
<ul>
<li>GitHub上的star /fork: <a target="_blank" rel="noopener" href="https://github.com/openfaas/faas-cli">faas-cli</a></li>
</ul>
<h3 id="教程-学习如何使用CLI"><a href="#教程-学习如何使用CLI" class="headerlink" title="教程: 学习如何使用CLI"></a>教程: 学习如何使用CLI</h3><p><a target="_blank" rel="noopener" href="https://blog.alexellis.io/quickstart-openfaas-cli/">Morning coffee with the OpenFaaS CLI</a></p>
<h2 id="创建新的函数"><a href="#创建新的函数" class="headerlink" title="创建新的函数"></a>创建新的函数</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>一旦你安装了<code>faas-cli</code>，你可以开始通过<code>faas-cli up</code>命令或使用单独的命令来创建和部署函数:</p>
<ul>
<li><code>faas-cli build</code>  构建映像到本地Docker库中</li>
<li><code>faas-cli push</code>  将该映像推到远程容器注册表</li>
<li><code>faas-cli deploy</code> 将函数部署到集群中</li>
</ul>
<p><code>faas-cli up</code>命令在一个命令中自动执行上述所有操作。</p>
<p>对于Raspberry Pi和ARM，你必须使用publish命令而不是build和push，或者up。</p>
<p>请看这里的注释:<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/094921046add2521.md">Building multi-arch images for ARM and Raspberry Pi</a></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>OpenFaaS CLI有一个内置的模板引擎，可以用给定的编程语言创建新的函数。它的工作方式是从当前工作文件夹中的<code>./template</code>位置读取模板列表。</p>
<p>在创建一个新函数之前，请确保您从GitHub通过 <a target="_blank" rel="noopener" href="https://github.com/openfaas/templates">templates repository</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faas-cli template pull</span><br></pre></td></tr></table></figure>

<p>本页面展示了如何在最流行的语言中生成函数，并解释了如何管理它们的依赖关系。</p>
<h3 id="Classic-vs-of-watchdog模板"><a href="#Classic-vs-of-watchdog模板" class="headerlink" title="Classic vs. of-watchdog模板"></a>Classic vs. of-watchdog模板</h3><p>经典模板保存在 <a target="_blank" rel="noopener" href="https://github.com/openfaas/templates">openfaas/templates</a>存储库中，并且基于使用STDIO与函数通信的<em>Classic Watchdog</em>。watchdog使用HTTP与函数进行通信，它的大多数模板都可以在GitHub上的<a target="_blank" rel="noopener" href="https://github.com/openfaas-incubator/">openfaas-incubator</a> 组织和商店中获得。</p>
<p>如何选择： </p>
<ul>
<li>如果你正在开始或遵循教程或指南，请使用<em>Classic Watchdog</em></li>
<li>如果您需要更高的性能或需要完全控制HTTP响应，请使用of-watchdog</li>
</ul>
<p>参考：  <a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/openfaas-0.20-en/e9ae346d3d971482.md">watchdog design</a></p>
<h3 id="存储过程注册模板"><a href="#存储过程注册模板" class="headerlink" title="存储过程注册模板"></a>存储过程注册模板</h3><p>您可以从官方商店浏览模板，或者创建自己的商店并在那里添加自己的模板。要查看哪些模板是可用的类型<code>faas-cli template store list</code>，你应该在终端中看到以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ faas-cli template store list</span><br><span class="line">NAME                    SOURCE             DESCRIPTION</span><br><span class="line">csharp                  openfaas           Official C# template</span><br><span class="line">dockerfile              openfaas           Official Dockerfile template</span><br><span class="line">...</span><br><span class="line">node10-express          openfaas-incubator NodeJS 10 Express template</span><br><span class="line">ruby-http               openfaas-incubator Ruby 2.4 HTTP template</span><br><span class="line">golang-middleware       openfaas-incubator Golang Middleware template</span><br><span class="line">csharp-httprequest      distantcam         C# HTTP template</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>选择一个模板并使用命令在本地检索它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ faas-cli template store pull node10-express</span><br></pre></td></tr></table></figure>

<p>下载后，您选择的模板和存储在同一存储库中的其他模板将可用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ faas-cli new --list</span><br><span class="line">Languages available as templates:</span><br><span class="line">- node10-express</span><br></pre></td></tr></table></figure>

<p>您可以通过为这两个命令指定<code>——url</code>标志来拉出并列出自定义模板存储，从而添加自己的存储。</p>
<p>经典模板保存在 <a target="_blank" rel="noopener" href="https://github.com/openfaas/templates">openfaas/templates</a> 存储库中。</p>
<h3 id="获取模板"><a href="#获取模板" class="headerlink" title="获取模板"></a>获取模板</h3><p>下面列出了几个可用的Golang模板。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Style</th>
<th align="left">Watchdog</th>
<th align="left">Dependencies</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>go</code></td>
<td align="left">Function</td>
<td align="left">classic</td>
<td align="left"><code>dep</code></td>
</tr>
<tr>
<td align="left"><code>golang-middleware</code></td>
<td align="left">Microservice</td>
<td align="left">of-watchdog</td>
<td align="left"><code>dep</code> or Go modules</td>
</tr>
<tr>
<td align="left"><code>golang-http</code></td>
<td align="left">Function</td>
<td align="left">of-watchdog</td>
<td align="left"><code>dep</code> or Go modules</td>
</tr>
</tbody></table>
<p>所有的模板都可以通过<code>faas-cli template store list/pull</code></p>
<h3 id="Go-golang-http-（of-watchdog-template）"><a href="#Go-golang-http-（of-watchdog-template）" class="headerlink" title="Go golang-http （of-watchdog template）"></a>Go <code>golang-http</code> （of-watchdog template）</h3><p><a target="_blank" rel="noopener" href="https://github.com/openfaas-incubator/golang-http-template">Read the README for golang-http</a>此模板具有与AWS Lambda类似的API。</p>
<p>Golang模块通过 <code>--build-arg</code> 使用 <code> GO111MODULE=1</code> 或者<code>GO111MODULE=auto</code></p>
<h4 id="Go-golang-middleware-of-watchdog-template"><a href="#Go-golang-middleware-of-watchdog-template" class="headerlink" title="Go golang-middleware - (of-watchdog template)"></a>Go <code>golang-middleware</code> - (of-watchdog template)</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/10/2021-11-10-%E9%9D%9E%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%ADvi%E7%BC%96%E8%BE%91%E5%99%A8%E6%97%B6%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA.swp%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/10/2021-11-10-%E9%9D%9E%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%ADvi%E7%BC%96%E8%BE%91%E5%99%A8%E6%97%B6%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA.swp%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">非正常关闭vi编辑器时会生成一个.swp文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-10T00:00:00+08:00">2021-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="非正常关闭vi编辑器时会生成一个-swp文件"><a href="#非正常关闭vi编辑器时会生成一个-swp文件" class="headerlink" title="非正常关闭vi编辑器时会生成一个.swp文件"></a>非正常关闭vi编辑器时会生成一个.swp文件</h3><p>使用vim，有时看到swp这个文件,这个文件是怎么产生的呢， 当你打开一个文件，vi就会生成这么一个.(filename)swp文件, 以备不测， 如果你正常退出，那么这个这个swp文件将会自动删除 。</p>
<p>不测分为：</p>
<ol>
<li>当你用多个程序编辑同一个文件时, 此时为了避免同一个文件产生两个不同的版本（vim中的原话），还是选择readonly为好。</li>
<li>非常规退出时， 可以用vim -r filename恢复，然后再把swp文件删除, 但要确保swp文件没有用了。 </li>
</ol>
<p>你可以使用来恢复文件</p>
<blockquote>
<p>vi -r {your file name}</p>
</blockquote>
<p>也可以删除swp文件，不然每一次编辑时总是有这个提示。</p>
<blockquote>
<p>rm .{your file name}.swp</p>
</blockquote>
<p>也可以再提示的时候选择<code>R</code>恢复， 恢复后swp文件还是存在，需要删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“.es-server.yaml.swp” already exists!</span><br><span class="line">[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit:</span><br></pre></td></tr></table></figure>

<p>选择<code>Edit anyway</code>，不能解决问题，下次打开文件的时候还是会提示。 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/08/2021-11-08-k8s%E5%A6%82%E4%BD%95%E4%B8%8Epod%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/08/2021-11-08-k8s%E5%A6%82%E4%BD%95%E4%B8%8Epod%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">k8s如何与pod通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-08T00:00:00+08:00">2021-11-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="pod通信和服务发现"><a href="#pod通信和服务发现" class="headerlink" title="pod通信和服务发现"></a>pod通信和服务发现</h3><p>在没有k8s的世界里，系统管理员要在用户端配置文件中明确服务的精确的ip地址或主机名来配置客户端的应用，但是在k8s中并不是需要。k8s中应用运行在pod中， 而pod的高可用设计使得无法保证准确的ip, 这里总结一下pod与服务的工作方式。</p>
<h4 id="1-pod特点"><a href="#1-pod特点" class="headerlink" title="1 pod特点"></a>1 pod特点</h4><ol>
<li>pod随时可能启动或关闭，是短暂的</li>
<li>客户端不会提前知道pod的地址，</li>
<li>水平伸缩以为着pod可能会提供相同的服务，每个pod ip不同，但客户端只需要服务，不需要知道pod的地址。 </li>
</ol>
<h4 id="2-服务"><a href="#2-服务" class="headerlink" title="2 服务"></a>2 服务</h4><p>为了解决上述需要，k8s为一组功能相同的pod提供单一不变的接入点，这就是服务。服务的ip和端口不会改变。客户端通过服务被路由pod上，而不需要直接连接pod,这样单个pod被移除或新的pod被创建就不影响。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/servicepod.png"></p>
<h4 id="3-pod与服务的匹配"><a href="#3-pod与服务的匹配" class="headerlink" title="3 pod与服务的匹配"></a>3 pod与服务的匹配</h4><p>上述的过程可以看出服务创建的一个基本问题，如何把服务和一组特定功能的pod匹配起来呢？ <strong>标签选择器</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/servicepod2.png"></p>
<h4 id="4-创建服务"><a href="#4-创建服务" class="headerlink" title="4  创建服务"></a>4  创建服务</h4><ol>
<li> 创建服务之前，先使用rc创建与之连接的pod </li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-rc.yaml &lt;&lt; EOF  </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata: </span><br><span class="line">  name: kubia</span><br><span class="line">spec: </span><br><span class="line">  replicas: 2</span><br><span class="line">  selector: </span><br><span class="line">    app: kubia </span><br><span class="line">  template: </span><br><span class="line">    metadata: </span><br><span class="line">      labels: </span><br><span class="line">        app: kubia</span><br><span class="line">    spec: </span><br><span class="line">      containers: </span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports: </span><br><span class="line">        - containerPort: 8080</span><br><span class="line">EOF</span><br><span class="line"># create </span><br><span class="line">kubectl create -f kubia-rc.yaml </span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@nginx test]# kubectl get po </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-66tvd   1/1     Running   0          2m31s</span><br><span class="line">kubia-v8dvv   1/1     Running   0          2m31s</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 创建服务 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-svc.yaml &lt;&lt; EOF </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata: </span><br><span class="line">  name: kubia</span><br><span class="line">spec: </span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 </span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector: </span><br><span class="line">    app: kubia </span><br><span class="line">EOF </span><br><span class="line"></span><br><span class="line"># create </span><br><span class="line">kubectl create -f kubia-svc.yaml</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@nginx test]# kubectl get svc </span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   16d</span><br><span class="line">kubia        ClusterIP   10.43.165.39   &lt;none&gt;        80/TCP    46s</span><br></pre></td></tr></table></figure>

<h4 id="5-为什么服务ip无法ping通-？"><a href="#5-为什么服务ip无法ping通-？" class="headerlink" title="5 为什么服务ip无法ping通 ？"></a>5 为什么服务ip无法ping通 ？</h4><p>我们发现服务curl是可以，但是无法ping通。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node01 ~]# curl  10.43.165.39 </span><br><span class="line">You&#x27;ve hit kubia-66tvd</span><br><span class="line">[root@k8s-node01 ~]# ping 10.43.165.39 </span><br><span class="line">PING 10.43.165.39 (10.43.165.39) 56(84) bytes of data.</span><br><span class="line">^C</span><br><span class="line">--- 10.43.165.39 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 received, 100% packet loss, time 999ms</span><br></pre></td></tr></table></figure>

<p>有的时候ping不通我们就认为出问题了，其实没有。这是因为集群ip是虚拟ip, 并且只有在与服务端口结合时才有意义。 所以ping不通是正常的。</p>
<h4 id="6-测试与分析"><a href="#6-测试与分析" class="headerlink" title="6 测试与分析"></a>6 测试与分析</h4><p>分配给该服务的ip是10.43.165.39， 但这是cluster-ip，也就是集群ip, 只能在集群内部可以访问。 也就是集群节点上或其他的pod可以访问。 是不是这样呢? 测试一下</p>
<ol>
<li> ssh到集群的一个节点上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node01 ~]# curl  10.43.165.39 </span><br><span class="line">You&#x27;ve hit kubia-66tvd </span><br><span class="line"># 服务的cluster ip 在集群内部，节点可与其通信</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 在pod中执行命令， 执行成功则说明连接</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 测试多次， 每次并不是同一个pod</span><br><span class="line">[root@nginx test]# kubectl exec kubia-vs2kl -- curl -s http://10.43.165.39</span><br><span class="line">You&#x27;ve hit kubia-vs2kl</span><br><span class="line"></span><br><span class="line">[root@nginx test]# kubectl exec kubia-vs2kl -- curl -s http://10.43.165.39</span><br><span class="line">You&#x27;ve hit kubia-l9w94</span><br><span class="line"></span><br><span class="line">[root@nginx test]# kubectl exec kubia-vs2kl -- curl -s http://10.43.165.39</span><br><span class="line">You&#x27;ve hit kubia-vs2kl</span><br></pre></td></tr></table></figure>

<blockquote>
<p> – 表示kubectl 命令结束，之后为在pod中执行的命令</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/servicepod3.png"></p>
<p>上图展示了事件发生的顺序</p>
<ol>
<li>在一个pod中执行命令，这个命令是发送http请求</li>
<li>pod向服务的ip发送请求 </li>
<li>由于这个服务是代理pod的，转发请求到其中一个pod上  </li>
<li>在pod2中处理请求，并返回带有pod名称的相应 </li>
<li>请求结果在主机上打印</li>
</ol>
<p>上述某一个过程出问题，都会使得上述命令失败，所以可用来测试集群网络。</p>
<h4 id="7-同一个服务暴露多个端口"><a href="#7-同一个服务暴露多个端口" class="headerlink" title="7 同一个服务暴露多个端口"></a>7 同一个服务暴露多个端口</h4><p>服务可以暴露一个端口，也可以多个端口。比如http监听8080端口，https监听8443端口。 多个端口需要指定名称, 没有设置名称的端口会在describe 时显示&lt;unset&gt; ， 如果pod中的端口也是命令的，svc中targetport可以使用其名称吗，这样在更换pod端口号的时候也不用修改服务了，因为其是根据名称匹配的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-svc.yaml &lt;&lt; EOF </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  - name: https</span><br><span class="line">    port: 443</span><br><span class="line">    targetPort: 8443</span><br><span class="line">selector:</span><br><span class="line">    app: kubia</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>

<h4 id="8-发现服务"><a href="#8-发现服务" class="headerlink" title="8  发现服务"></a>8  发现服务</h4><p>创建服务后， 我们可以通过单一稳定的ip访问到pod， 不管pod如何变化都不影响。 但是在某个服务创建之后新建的pod如何知道服务的ip呢？ 难道手动查询吗? 不需要。</p>
<p>k8s为客户端提供了发现服务的ip和端口的方式——环境变量， 在pod开始运行的时候，k8s会初始化一系列的环境变量指向现在存在的服务。如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx test]# kubectl exec kubia-vs2kl -- env</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kubia-vs2kl</span><br><span class="line">KUBERNETES_PORT=tcp://10.43.0.1:443</span><br><span class="line">KUBIA_PORT_80_TCP_PORT=80</span><br><span class="line">KUBIA_PORT=tcp://10.43.165.39:80</span><br><span class="line">KUBIA_PORT_80_TCP=tcp://10.43.165.39:80</span><br><span class="line">KUBIA_PORT_80_TCP_PROTO=tcp</span><br><span class="line">KUBIA_PORT_80_TCP_ADDR=10.43.165.39</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=10.43.0.1</span><br><span class="line">KUBIA_SERVICE_HOST=10.43.165.39</span><br><span class="line">KUBIA_SERVICE_PORT=80</span><br><span class="line">NPM_CONFIG_LOGLEVEL=info</span><br><span class="line">NODE_VERSION=7.9.0</span><br><span class="line">YARN_VERSION=0.22.0</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure>

<h4 id="9-DNS"><a href="#9-DNS" class="headerlink" title="9 DNS"></a>9 DNS</h4><p>环境变量是获取ip和端口的一种方式，也可以通过DNS获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx test]# kubectl get po -n kube-system </span><br><span class="line">NAME                                      READY   STATUS      RESTARTS   AGE</span><br><span class="line">canal-l58m7                               2/2     Running     2          16d</span><br><span class="line">canal-s92dx                               2/2     Running     3          16d</span><br><span class="line">coredns-7c5566588d-rhdtx                  1/1     Running     1          16d</span><br><span class="line">coredns-7c5566588d-tp55c                  1/1     Running     1          16d</span><br><span class="line">coredns-autoscaler-65bfc8d47d-4mdt5       1/1     Running     1          16d</span><br><span class="line">metrics-server-6b55c64f86-zlz4l           1/1     Running     2          16d</span><br></pre></td></tr></table></figure>

<p>kube-system空间中pod有coredns，这表明在运行dns服务，在集群中的其他pod都被配置成使用作为为DNS ， 运行在pod上的进程DNS 查询都会被k8s自身的DNS服务器响应，该服务器知道系统中运行的所有服务。pod中的spec中的dnspolicy值决定是否使用DNS服务器。 </p>
<h4 id="10-endpoints"><a href="#10-endpoints" class="headerlink" title="10 endpoints"></a>10 endpoints</h4><p>我们也希望k8s将服务暴露到外部，在此之前要先介绍一下endpoint, 它是介于pod和svc之间的资源。 就是暴露服务要转发的pod的ip地址和端口的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 查看endpoints</span><br><span class="line">[root@nginx test]# kubectl get endpoints  kubia </span><br><span class="line">NAME    ENDPOINTS                                                    AGE</span><br><span class="line">kubia   10.42.0.10:8443,10.42.1.10:8443,10.42.1.9:8443 + 3 more...   79m</span><br><span class="line"></span><br><span class="line"># 查看pod IP</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE    IP           NODE            NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia-66tvd   1/1     Running   0          161m   10.42.0.10   81.68.101.212   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-l9w94   1/1     Running   0          128m   10.42.1.9    81.68.229.215   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-vs2kl   1/1     Running   0          125m   10.42.1.10   81.68.229.215   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"># 从svc中也可以看到， endpoints就是待转发pod的IP与端口的集合</span><br><span class="line">[root@nginx test]# kubectl describe svc kubia </span><br><span class="line">Name:              kubia</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=kubia</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP Families:       &lt;none&gt;</span><br><span class="line">IP:                10.43.7.83</span><br><span class="line">IPs:               &lt;none&gt;</span><br><span class="line">Port:              http  80/TCP</span><br><span class="line">TargetPort:        8080/TCP</span><br><span class="line">Endpoints:         10.42.0.10:8080,10.42.1.10:8080,10.42.1.9:8080</span><br><span class="line">Port:              https  443/TCP</span><br><span class="line">TargetPort:        8443/TCP</span><br><span class="line">Endpoints:         10.42.0.10:8443,10.42.1.10:8443,10.42.1.9:8443</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>这表明服务是利用标签匹配pod， 然后建立endpoints,  将请求转发的endpoints中的一个ip: port上。 所以有的时候服务连接失败，需要查看endpoints是否存在正确。</p>
<p>了解到这一层之后，我们也可以不使用标签匹配pod，手动为服务建立endpoints，只要新建一个endpoints资源，使其与服务的名称相同即可。 </p>
<blockquote>
<p>endpoints本身就是一个资源，而不是service的一部分。</p>
</blockquote>
<h4 id="11-将服务暴露给外部"><a href="#11-将服务暴露给外部" class="headerlink" title="11 将服务暴露给外部"></a>11 将服务暴露给外部</h4><p>目前为止，讨论了集群内部pod的使用。有时我们需要将服务暴露给集群之外的网络，比如前端web服务器。有几种方式可以在外部访问服务。 </p>
<ol>
<li>nodeport型的服务，在集群的每个节点上打开一个端口，因此叫nodeport，将该端口山的流量重定向到服务上，使用集群ip:port既可以访问。 </li>
<li>loadbalance型服务，是nodeport的一种扩展， 这使得服务可以通过一个专用的负载均衡器来访问。 </li>
<li>ingress资源，这是一个完全不同的机制，通过一个ip地址公开多个服务——它运行在http层，因此可以比第四层的服务提供更多的资源。 </li>
</ol>
<p>第一种： 使用nodeport暴露服务到外部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-svc-nodeport.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1 </span><br><span class="line">kind: Service </span><br><span class="line">metadata: </span><br><span class="line">  name: kubia-nodeport </span><br><span class="line">spec: </span><br><span class="line">  type: NodePort </span><br><span class="line">  ports: </span><br><span class="line">  - port: 80 </span><br><span class="line">    targetPort: 8080 </span><br><span class="line">    nodePort: 30123 </span><br><span class="line">  selector: </span><br><span class="line">    app: kubia </span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 创建</span><br><span class="line">kubectl create -f kubia-svc-nodeport.yaml</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@nginx test]# kubectl get svc kubia-nodeport -o wide </span><br><span class="line">NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE   SELECTOR</span><br><span class="line">kubia-nodeport   NodePort   10.43.254.206   &lt;none&gt;        80:30123/TCP   38m   app=kubia</span><br><span class="line"></span><br><span class="line"># 测试， 本地shell连接 </span><br><span class="line">[C:\~]$ curl http://81.68.229.215:30123</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    23    0    23    0     0     23      0 --:--:-- --:--:-- --:--:--  1533</span><br><span class="line">You&#x27;ve hit kubia-l9w94</span><br><span class="line"># 这表明外部网络可以连接到集群内部的服务，用浏览器也可以打开。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/servicepod4.png"></p>
<p>第二种： 使用loadbalance暴露服务到外部</p>
<p>对于提供负载均衡器的云构架才可以使用loadbalancer, 如果不支持则nodebanlancer型svc将退化为nodeport。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-svc-loadbalancer.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1 </span><br><span class="line">kind: Service</span><br><span class="line">metadata: </span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec: </span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports: </span><br><span class="line">  - port: 80 </span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector: </span><br><span class="line">    app: kubia</span><br><span class="line">EOF</span><br><span class="line"># 创建</span><br><span class="line">kubectl create -f kubia-svc-loadbalancer.yaml</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@nginx ~]# kubectl get svc </span><br><span class="line">NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes           ClusterIP      10.43.0.1       &lt;none&gt;        443/TCP          17d</span><br><span class="line">kubia                ClusterIP      10.43.7.83      &lt;none&gt;        80/TCP,443/TCP   18h</span><br><span class="line">kubia-loadbalancer   LoadBalancer   10.43.20.104    &lt;pending&gt;     80:31342/TCP     14m</span><br><span class="line">kubia-nodeport       NodePort       10.43.254.206   &lt;none&gt;        80:30123/TCP     16h</span><br><span class="line">nginx-service        NodePort       10.43.66.77     &lt;none&gt;        80:30080/TCP     16h</span><br><span class="line"></span><br><span class="line"># 测试， 本集群不支持loadbalancer, 所以external-ip状态为pending, 此时loadbalancer就是一个nodeport</span><br><span class="line"># 本地shell测试 node-ip:port ， 连接正常</span><br><span class="line">[C:\~]$ curl http://81.68.229.215:31342</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    23    0    23    0     0     23      0 --:--:-- --:--:-- --:--:--   741</span><br><span class="line">You&#x27;ve hit kubia-vs2kl</span><br><span class="line"></span><br><span class="line"># 换一个腾讯云的弹性集群测试，支持负载均衡器</span><br><span class="line"># 部署同样的deployment, 然后部署loadlancer, 过程相同，省略 </span><br><span class="line"># 查看 </span><br><span class="line">[root@k8s-node02 ~]# kubectl get svc </span><br><span class="line">NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE</span><br><span class="line">kubernetes           ClusterIP      192.168.0.1     &lt;none&gt;           443/TCP        3d23h</span><br><span class="line">kubia-loadbalancer   LoadBalancer   192.168.0.201   175.27.192.232   80:30493/TCP   67s</span><br><span class="line"># 本地主机测试 </span><br><span class="line">[C:\~]$ curl http://175.27.192.232</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    33    0    33    0     0     33      0 --:--:-- --:--:-- --:--:--   702</span><br><span class="line">You&#x27;ve hit kubia-778d98d9c-2zpl5</span><br><span class="line"></span><br><span class="line"># 成功了， 直接访问loadbalancer IP即可</span><br></pre></td></tr></table></figure>

<p>第三种: ingress </p>
<p>为什么需要ingress呢， loadbalancer服务需要独立的共有IP地址，二ingress只需要一个公网IP就可以为许多服务提供访问。 当客户向ingress发送请求时，ingress会根据请求的主机名和路径决定请求转发的服务。也就是一个ingress可以暴露多个服务。如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/servicepod7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubia-ingress.yaml &lt;&lt; EOF </span><br><span class="line">apiVersion: extensions/v1beta1 </span><br><span class="line">kind: Ingress </span><br><span class="line">metadata: </span><br><span class="line">  name: kubia</span><br><span class="line">spec: </span><br><span class="line">  rules: </span><br><span class="line">  - host: kubia.example.com </span><br><span class="line">    http: </span><br><span class="line">      paths: </span><br><span class="line">      - path: / </span><br><span class="line">        backend: </span><br><span class="line">          serviceName: kubia-nodeport </span><br><span class="line">          servicePort: 80</span><br><span class="line">EOF</span><br><span class="line"># 创建</span><br><span class="line">kubectl create -f kubia-ingress.yaml </span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">[root@k8s-node02 ~]# kubectl get ing </span><br><span class="line">NAME    CLASS    HOSTS               ADDRESS        PORTS   AGE</span><br><span class="line">kubia   &lt;none&gt;   kubia.example.com   119.45.3.217   80      34m</span><br><span class="line"></span><br><span class="line"># 访问， 本地要添加dns </span><br><span class="line"># windows在‪C:\Windows\System32\drivers\etc\hosts </span><br><span class="line"># 添加 </span><br><span class="line">119.45.3.217  kubia.example.com</span><br><span class="line"># 访问 </span><br><span class="line">[C:\~]$ curl http://1.13.12.141</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    33    0    33    0     0     33      0 --:--:-- --:--:-- --:--:--   532</span><br><span class="line">You&#x27;ve hit kubia-778d98d9c-2zpl5</span><br><span class="line"></span><br><span class="line">[C:\~]$ curl http://kubia.example.com</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0</span><br><span class="line">You&#x27;ve hit kubia-778d98d9c-2zpl5</span><br></pre></td></tr></table></figure>

<blockquote>
<p> ingress意为进入或进入的行为，进入的手段和地点</p>
<p>使用ingress，访问链路为客户端——ingress——service——工作负载， 所以ingress配置的时候一定要保证service正常工作，而且serviceName为转发service的名称。</p>
</blockquote>
<p>参考资料： kubernets in action –服务：客户端发现pod并与之通信</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/11/03/2021-11-03-%E5%9B%9B%E6%88%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1HA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/03/2021-11-03-%E5%9B%9B%E6%88%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1HA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">四成负载均衡HA集群搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-03T00:00:00+08:00">2021-11-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一-集群介绍"><a href="#一-集群介绍" class="headerlink" title="一 集群介绍"></a>一 集群介绍</h3><p>使用高可用配置的方式在生产环境安装 Rancher，用户可以一直访问 Rancher 服务。在 Kubernetes 集群中安装 Rancher 时，Rancher 会与集群的 etcd 数据库集成，并利用 Kubernetes 调度来实现高可用。下面将使用 RKE 来部署三个节点的集群，并使用 Helm 安装 Rancher。</p>
<p>我们还需要设置一个负载均衡器，以将流量定向到两个节点上的 Rancher 副本。这样可以在单个节点不可用时，继续保障与 Rancher 管理面的连接。</p>
<p>在安装 Rancher 时，Rancher 系统将创建一个 Ingress 资源。该 Ingress 通知 Traefik Ingress 控制器侦听发往 Rancher 主机名的流量。Traefik Ingress 控制器在收到发往 Rancher 主机名的流量时，会将其转发到集群中正在运行的 Rancher Server Pod。</p>
<ul>
<li><strong>4 层负载均衡器</strong> 将 TCP 流量转发到节点。我们建议使用 4 层负载均衡器，将流量从 TCP / 80 端口和 TCP / 443 端口转发到 Rancher 管理面的集群节点上。集群上的 Ingress 控制器会将 HTTP 流量重定向到 HTTPS，并在 TCP / 443 端口上终止 SSL / TLS。Ingress 控制器会将流量转发到 Rancher Server Pod 的 TCP / 443 端口。</li>
</ul>
<h3 id="二-集群部署"><a href="#二-集群部署" class="headerlink" title="二  集群部署"></a>二  集群部署</h3><p>使用RKE部署集群包括四个部分</p>
<ol>
<li>准备工作，包括云主机或虚拟机硬件、软件和网络配置。部署的集群的要求，可以查看<a target="_blank" rel="noopener" href="https://docs.rancher.cn/">rancher官方文档</a></li>
<li>rke部署集群, 包括安装rke，新建操作的普通用户，主节点免密登陆，集群的配置文件，启动集群。</li>
<li>部署rancher web，这里通过helm3部署，需要安装helm3, 生成自签名证书，启动rancher web服务。  </li>
<li>通过rancher server调试集群</li>
</ol>
<blockquote>
<p>什么是RKE? </p>
<p>Rancher Kubernetes Engine，简称 RKE，是一个经过 CNCF 认证的 Kubernetes 安装程序。RKE 支持多种操作系统，包括 MacOS、Linux 和 Windows，可以在裸金属服务器（BMS）和虚拟服务器（Virtualized Server）上运行。市面上的其他 Kubernetes 部署工具存在一个共性问题：在使用工具之前需要满足的先决条件比较多，例如，在使用工具前需要完成安装 kubelet、配置网络等一系列的繁琐操作。而 RKE 简化了部署 Kubernetes 集群的过程，只有一个先决条件：只要您使用的 Docker 是 RKE 支持的版本，就可以通过 RKE 安装 Kubernetes，部署和运行 Kubernetes 集群。RKE 既可以单独使用，作为创建 Kubernetes 集群的工具，也可以配合 Rancher2.x 使用，作为 Rancher2.x 的组件，在 Rancher 中部署和运行 Kubernetes 集群。</p>
</blockquote>
<h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h4><p><code>1.1 设置节点hostname</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx 192.168.2.40</span><br><span class="line">node1 192.168.2.51</span><br><span class="line">node2 192.168.2.52</span><br><span class="line">node3 192.168.2.53</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx ~]# hostnamectl set-hostname nginx</span><br><span class="line">[root@node1 ~]# hostnamectl set-hostname node1</span><br><span class="line">[root@node2 ~]# hostnamectl set-hostname node2</span><br><span class="line">[root@node3 ~]# hostnamectl set-hostname node3</span><br></pre></td></tr></table></figure>

<p><code>1.2 主机名DNS解析</code><br>主机名DNS解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.2.40 nginx</span><br><span class="line">192.168.2.51 node1</span><br><span class="line">192.168.2.52 node2</span><br><span class="line">192.168.2.53 node3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p><code>1.3 关闭防火墙</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p><code>1.4 关闭swap</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a # 临时关闭；关闭swap主要是为了性能考虑</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab # 永久关闭</span><br></pre></td></tr></table></figure>

<p><code>1.6 关闭selinux </code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0 # 临时关闭</span><br><span class="line">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config # 永久关闭</span><br></pre></td></tr></table></figure>

<p><code>1.6 同步时间</code></p>
<p>这样可以防止在客户端和服务器之间因为时钟不同步而发生证书验证错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br></pre></td></tr></table></figure>

<p><code>1.7 kernel性能调优</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/sysctl.conf&lt;&lt;EOF</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.ipv4.neigh.default.gc_thresh1=4096</span><br><span class="line">net.ipv4.neigh.default.gc_thresh2=6144</span><br><span class="line">net.ipv4.neigh.default.gc_thresh3=8192</span><br><span class="line">EOF</span><br><span class="line"># 加载配置文件</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>



<p><code>1.8 安装基础软件包</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz vim gcc glibc openssl openssl-devel net-tools wget curl</span><br></pre></td></tr></table></figure>

<h4 id="2-部署集群"><a href="#2-部署集群" class="headerlink" title="2 部署集群"></a>2 部署集群</h4><p><code>2.1 安装docker</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装18.09.9稳定版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9-3.el7</span><br></pre></td></tr></table></figure>

<p>启动docker </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>配置镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;oom-score-adjust&quot;: -1000,</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://7bezldxe.mirror.aliyuncs.com/&quot;,&quot;https://kw88y6eh.mirror.aliyuncs.com&quot;],</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">    &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>重启并设置自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"># systemctl  status docker 查看docker状态</span><br></pre></td></tr></table></figure>



<p><code>2.2  安装ctl工具</code> </p>
<p>下载安装工具rke,kubectl </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># rke下载地址：https://github.com/rancher/rke/tags，下载v1.0.4</span><br><span class="line">chmod +x rke_linux-amd64 </span><br><span class="line">mv rke_linux-amd64 /usr/bin/rke</span><br><span class="line"></span><br><span class="line"># kubectl </span><br><span class="line">wget http://storage.googleapis.com/kubernetes-release/release/v1.17.2/bin/linux/amd64/kubectl</span><br><span class="line">chmod +x kubectl </span><br><span class="line">mv kubectl /usr/bin/kubectl</span><br></pre></td></tr></table></figure>
<p><code>2.3 设置节点免密登陆</code></p>
<p>rke不支持root用户，所以新建普通用户操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd rancher -G docker</span><br><span class="line">echo &quot;123456&quot; | passwd --stdin rancher</span><br></pre></td></tr></table></figure>

<p>授权免密登陆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su - rancher</span><br><span class="line">cd /home/rancher</span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id rancher@192.168.2.51</span><br><span class="line">ssh-copy-id rancher@192.168.2.52</span><br><span class="line">ssh-copy-id rancher@192.168.2.53</span><br></pre></td></tr></table></figure>
<p>集群配置yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; cluster.yml &lt;&lt; EOF</span><br><span class="line">nodes:</span><br><span class="line">  - address: 192.168.2.51</span><br><span class="line">    internal_address: 192.168.2.51</span><br><span class="line">    user: rancher</span><br><span class="line">    role: [controlplane,worker,etcd]</span><br><span class="line">  - address: 192.168.2.52</span><br><span class="line">    internal_address: 192.168.2.52</span><br><span class="line">    user: rancher</span><br><span class="line">    role: [controlplane,worker,etcd]</span><br><span class="line">  - address: 192.168.2.53</span><br><span class="line">    internal_address: 192.168.2.53</span><br><span class="line">    user: rancher</span><br><span class="line">    role: [controlplane,worker,etcd]</span><br><span class="line">services:</span><br><span class="line">    etcd:</span><br><span class="line">      snapshot: true</span><br><span class="line">      creation: 6h</span><br><span class="line">      retention: 24h</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>创建Kubernetes集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 运行RKE命令创建Kubernetes集群</span><br><span class="line">rke up --config ./cluster.yml</span><br></pre></td></tr></table></figure>

<blockquote>
<p>保存kube_config_rancher-cluster.yml和rancher-cluster.yml文件的副本，后期将需要这些文件来维护和升级Rancher实例。</p>
</blockquote>
<p>配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">### 切换到root用户</span><br><span class="line">su - root</span><br><span class="line">vim /etc/profile</span><br><span class="line">export KUBECONFIG=/home/rancher/kube_config_cluster.yml</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>查看集群状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/rke1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/rke2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Yuanwanli1995/markdown_pic@main/blogpic/rke3.png"></p>
<p><code>2.4  配置nginx代理</code> </p>
<p>安装nginx，这里最新版本的可能出现模块错误，安装稳定版的。</p>
<p>添加nginx repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo </span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>

<p>yum直接安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 卸载旧版 nginx #yum -y remove nginx</span><br><span class="line">yum -y install nginx-1.18.0 </span><br></pre></td></tr></table></figure>

<p>配置nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/nginx/nginx.conf &lt;&lt; EOF </span><br><span class="line">worker_processes 4;</span><br><span class="line">worker_rlimit_nofile 40000;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 8192;</span><br><span class="line">&#125;</span><br><span class="line">stream &#123;</span><br><span class="line">    upstream rancher_servers_http &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.2.51:80 max_fails=3 fail_timeout=5s;</span><br><span class="line">        server 192.168.2.52:80 max_fails=3 fail_timeout=5s;</span><br><span class="line">        server 192.168.2.53:80 max_fails=3 fail_timeout=5s;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        proxy_pass rancher_servers_http;</span><br><span class="line">&#125;</span><br><span class="line">    upstream rancher_servers_https &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.2.51:443 max_fails=3 fail_timeout=5s;</span><br><span class="line">        server 192.168.2.52:443 max_fails=3 fail_timeout=5s;</span><br><span class="line">        server 192.168.2.53:443 max_fails=3 fail_timeout=5s;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen     443;</span><br><span class="line">        proxy_pass rancher_servers_https;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 测试 </span><br><span class="line">cat &gt; /etc/nginx/nginx.conf &lt;&lt; EOF </span><br><span class="line">worker_processes 4;</span><br><span class="line">worker_rlimit_nofile 40000;</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 8192;</span><br><span class="line">&#125;</span><br><span class="line">stream &#123;</span><br><span class="line">	upstream rancher &#123;</span><br><span class="line">        server 192.168.30.110:80;</span><br><span class="line">        server 192.168.30.129:80;</span><br><span class="line">        server 192.168.30.133:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">        default Upgrade;</span><br><span class="line">        &#x27;&#x27;      close;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl http2;</span><br><span class="line">        server_name cf.rancher.com;</span><br><span class="line">        ssl_certificate /home/admin/certs/tls.crt;</span><br><span class="line">        ssl_certificate_key /home/admin/certs/tls.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://rancher;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection $connection_upgrade;</span><br><span class="line">            # 这里将允许您在 Rancher UI 中打开命令行窗口时，窗口可以保留最多15分钟。没有这个参数时，默认值为1分钟，一分钟后在Rancher&gt;中的shell会自动关闭。</span><br><span class="line">            proxy_read_timeout 900s;</span><br><span class="line">            proxy_buffering off;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name cf.rancher.com;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -t  # 测试语法是否有误</span><br><span class="line">nginx -c /etc/nginx/nginx.conf # 设置配置文件</span><br><span class="line">nginx -s reload # 加载更改的配置文件</span><br></pre></td></tr></table></figure>

<p>启动服务，设定nginx自启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>

<p><code>2.5  故障处理</code> </p>
<p>这里可能会出现几个问题： </p>
<p><code>问题1  </code> unknown directive “stream”</p>
<p>先检查nginx的配置有没有错误，或者有没有tab空格，nginx是不支持tab空格的，可以使用下面命令检查格式，对齐或者空格 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A  /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>如果配置确实没有问题，也有可能是nginx版本问题, 换稳定版的nginx。 </p>
<p><code>问题2</code> 缺少 “/var/run/nginx.pid”文件</p>
<p>解决方法， 没有就新建一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/run/</span><br><span class="line">touch nginx.pid</span><br></pre></td></tr></table></figure>

<p><code>问题3</code> nginx: [error] invalid PID number “” in “/var/run/nginx.pid”</p>
<p>解决，先执行ngingx -c， 再加载配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p><code>问题4</code> 80/443端口被占用, 如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Job for nginx.service failed because the control process exited with error code. See &quot;systemctl status nginx.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">[root@nginx ~]systemctl status nginx.service</span><br><span class="line">bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">bind() to 0.0.0.0:443 failed (98: Address already in use)</span><br></pre></td></tr></table></figure>

<p>要先关闭服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>

<p>如果还是不行，可能是端口被其应用占用，就查看一下占用的进程，这里直接清理占用的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuser -k 80/tcp</span><br><span class="line">fuser -k 443/tcp</span><br></pre></td></tr></table></figure>

<h4 id="3-部署rancher-server"><a href="#3-部署rancher-server" class="headerlink" title="3 部署rancher server"></a>3 部署rancher server</h4><p><code>3.1 安装helm  </code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#helm下载地址：https://github.com/helm/helm/tags </span><br><span class="line">tar -zxf helm-v3.2.4-linux-amd64.tar.gz </span><br><span class="line">mv linux-amd64/helm /usr/bin/helm</span><br><span class="line">rm -rf helm-v3.2.4-linux-amd64.tar.gz linux-amd64</span><br></pre></td></tr></table></figure>

<blockquote>
<p>helm3与helm2不同，是不需要安装tiller的</p>
</blockquote>
<p><code>3.2 部署rancher web服务</code></p>
<p>添加Chart仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用helm repo add命令添加Rancher chart仓库地址，访问Rancher tag和Chart版本</span><br><span class="line"># 替换&lt;CHART_REPO&gt;为您要使用的Helm仓库分支(即latest或stable）。</span><br><span class="line"># helm repo add rancher-stable https://releases.rancher.com/server-charts/stable</span><br><span class="line"># 国内可用镜像</span><br><span class="line"># helm repo add rancher-stable http://rancher-mirror.oss-cn-beijing.aliyuncs.com/server-charts/stable</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>

<p>Rancher Server 默认需要 SSL/TLS 配置来保证访问的安全性，这里我们选择自签名的证书</p>
<p>这里使用官方文档给的生成证书的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssl</span><br><span class="line">cd ssl/</span><br><span class="line">chmod +x create_self-signed-cert.sh  # 执行权限</span><br><span class="line">#然后再用这个脚本生成ssl证书</span><br><span class="line">./create_self-signed-cert.sh --ssl-domain=my.rancher.com --ssl-trusted-ip=192.168.0.41 --ssl-size=2048 --ssl-date=3650</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看证书</span><br><span class="line">[root@node1 ssl]# ls</span><br><span class="line">cacerts.pem  cacerts.srl  cakey.pem  create_self-signed-cert.sh  my.rancher.com.crt  my.rancher.com.csr  my.rancher.com.key  openssl.cnf  tls.crt  tls.key</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 为rancher创建命名空间</span><br><span class="line">kubectl create namespace cattle-system</span><br><span class="line"></span><br><span class="line"># 服务证书和私钥密文</span><br><span class="line">kubectl -n cattle-system create \</span><br><span class="line">    secret tls tls-rancher-ingress \</span><br><span class="line">    --cert=/home/rancher/ssl/tls.crt \</span><br><span class="line">    --key=/home/rancher/ssl/tls.key</span><br><span class="line"></span><br><span class="line"># ca证书密文</span><br><span class="line">kubectl -n cattle-system create secret \</span><br><span class="line">    generic tls-ca \</span><br><span class="line">    --from-file=/home/rancher/ssl/cacerts.pem</span><br></pre></td></tr></table></figure>

<p>安装rancher server </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helm install rancher rancher-stable/rancher \</span><br><span class="line">    --namespace cattle-system \</span><br><span class="line">    --set hostname=my.rancher.com \</span><br><span class="line">    --set ingress.tls.source=secret \</span><br><span class="line">    --set privateCA=true</span><br><span class="line"># hostname需要与证书对应的域名匹配，否则ingress将无法代理访问Rancher。</span><br></pre></td></tr></table></figure>

<p>my.rancher.com是后面访问rancher的域名，需要在/etc/hosts文件中添加关联（所有主机）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]$ echo &quot;192.168.0.41 my.rancher.com&quot; &gt;&gt; /etc/hosts</span><br><span class="line">[root@node2 ~]$ echo &quot;192.168.0.41 my.rancher.com&quot; &gt;&gt; /etc/hosts</span><br><span class="line">[root@node3 ~]$ echo &quot;192.168.0.41 my.rancher.com&quot; &gt;&gt; /etc/hosts</span><br><span class="line">[root@nginx ~]$ echo &quot;192.168.0.41 my.rancher.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<p><code>3.4 容器配置hosts:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n cattle-system patch deployments rancher --patch &#x27;&#123;</span><br><span class="line">    &quot;spec&quot;: &#123;</span><br><span class="line">        &quot;template&quot;: &#123;</span><br><span class="line">            &quot;spec&quot;: &#123;</span><br><span class="line">                &quot;hostAliases&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;hostnames&quot;:</span><br><span class="line">                        [</span><br><span class="line">                            &quot;my.rancher.com&quot;</span><br><span class="line">                        ],</span><br><span class="line">                            &quot;ip&quot;: &quot;192.168.2.40&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><code>3.5 添加本机hosts</code><br>将刚刚的域名映射关系写入到Windows主机的hosts文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.100 my.rancher.com</span><br></pre></td></tr></table></figure>

<h4 id="4-访问rancher-server"><a href="#4-访问rancher-server" class="headerlink" title="4 访问rancher server"></a>4 访问rancher server</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Happy Containering!</span><br><span class="line">[root@node1 ssl]# echo https://my.rancher.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#x27;)</span><br><span class="line">https://my.rancher.com/dashboard/?setup=</span><br><span class="line">[root@node1 ssl]# kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=&#x27;&#123;&#123;.data.bootstrapPassword|base64decode&#125;&#125;&#123;&#123; &quot;\n&quot; &#125;&#125;&#x27;</span><br><span class="line">b9bwmrwrs7ndzrpvn6lnqc22hmtf7wbdpkpxh652jbrcbkhtlgxsd2</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/10/31/2021-10-31-%E3%80%8A%E5%91%A8%E6%81%A9%E6%9D%A5%E4%BC%A0%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/31/2021-10-31-%E3%80%8A%E5%91%A8%E6%81%A9%E6%9D%A5%E4%BC%A0%E3%80%8B/" class="post-title-link" itemprop="url">《周恩来传》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-31T00:00:00+08:00">2021-10-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="《周恩来传》"><a href="#《周恩来传》" class="headerlink" title="《周恩来传》"></a>《周恩来传》</h2><p>原文摘录：</p>
<ul>
<li> 在人们看来，赫鲁晓夫可能令人恼怒地攻击过周的阶级出身“你的这种批评很好，周同志，”他说，“不过你得承认，我来自工人阶级，而你却出于资产阶级家庭。” 一 阵沉默。而后，周镇静地答道：“是的，赫鲁晓夫同志。但是我俩少有一点是共同的，我们俩都背叛了自己的阶级。” </li>
<li>周思来同志 我们要造你一点反，就是请求你改变现在的工作方式和生活习惯，以适应你的身体变化情，从而你才能为党工作得长久一些，更多一些。这是我们从党和革命的最高的长远的利益出发。所以强烈地请求你接受我们的恳求。</li>
<li>周开始向外国人解释为什么中国不能像西方国家那样行事。他告诉一位外国记者： 中国不能轻率地实行像美国、英国和其他真正民主国家那样的民主。中国人民受过长期的压迫，在他们理解诚实投票的重要性和意义之前，还需要几代人的政治训练。我们还没有为一个彻底的民主制度做好准备。我们必须慢慢来。</li>
<li>司徒雷登本想在6月底访问北京，但未能成行，他收到周一封相当消极的私人信件，该信件戳了一些老伤疤，周取消了对司徒雷登的邀请。几周后又把这个运气不佳的大使描绘成“惯于以和蔼可亲的面目掩盖其虚伪和欺骗”。 周的直率和他那不装模作样的共产主义作风在1949年夏季中的一次讲演中大放光彩，他在北京的一次青年大会上对那些共产主义的下一代谈到毛时说，毛是一个伟人，但与普通人没什么两样，他不应该被看成是“一个偶然的、天生的、神秘的、无法学习的领袖”，年轻人向他学实习时应该从他的历史发展来学习，不要只看今天的成就伟大而不看历史的发展”，昨天迷信的孩子可以变成今天的毛主席(当然，我不是说所有的孩子都可以成毛主席)。他再次提醒说，毛也曾在农村问题上犯过错误。然而，毛已经开始美化他自己的历史，允许献媚的助手去篡改文献。这一腐败倾向在7年前的“整风运动”中就开始了。 周讲话结束时表示完全同意刘少奇对毛的赞扬之词，即毛成功地运用普遍真理于中国的实际。但他补充说，为了使老百姓在这一真理中受益，必须首先通过教育和宣传来使他们提高政治觉悟，因此，周正确地预见了以后10年中国的政策路线斗争，表明他选择了一种缓慢而实用的变革进程，而不是向一种难以捉摸的社会主义作疯狂冲刺。</li>
<li>中国不能轻率地实行像美国、英国和其他真正的民主国家那样的民主。中国人民受过长期的压迫，在他们理解诚实投票的重要性和意义之前，还需要几代人的政治训练。我们还没有为一个初底的民主制度做好准备。我们必须慢慢来。</li>
<li>在一次修面时，周恩来突然咳嗽起来，结果理发师刮破了他的下巴。周恩来看到他那惶恐的样子，迅速道歉说：“我本该在咳嗽前先给你打声招呼。”</li>
<li>周恩来一直没有遭到什么毁灭性的麻烦，因为毛泽东和江青都需要他。甚至在某种程度上，当默默羞辱他的时候，他们也需要利用他那别人无法比拟的才能。</li>
<li>在天安门出现了这样一份悼词，它写道：“他没有遗产，他没有嗣息，他没有坟墓，他也没有留下骨灰，他的骨灰撒在祖国的山河中。他似乎什么也没有给我们留下，但是他拥有全中国，他儿孙好几亿，遍地黄士都是他的。”</li>
<li>他的考虑是对方既富有，家中又有权势，自己家中贫穷，将来会受制于人。</li>
<li>从高级领导层看，这场“文化大革命”也可算作一场夺权的斗争。在斗争中，毛泽东依靠他与周来和代表军队的林彪建立的强大联盟，从刘少奇手中重新夺回了他的领导权。西方观察家一般都认为周恩来是一个温和派，但在这场特殊的斗争中，他与毛泽东站在一起。这可能是因为他更信任、尊敬毛泽东。周恩来与他亲密地共同工作了35年，而刘少奇与周恩来却不太熟悉。</li>
<li>诱使一个世界上最有权力的政治领导人，同时也是一个长期以来对中国共产主义怀有深仇大恨的国家的元首来中国进行官方访问(他的政府甚至还没有承认中国)并与中国领导人就悬而未决的双边问题进行谈判，这是周恩来长期外交生涯中最辉煌的成就。甚至周恩来自己也用同样夸张的语言把它称为国际关系中令人高兴的一个突破。</li>
<li>一名医生后来回忆说：“周恩来是被逼死的。······他们不让他休息。······甚至在我们给周总理输血时，江青也会挂电话来命令在她与总理说话时停止输血，她尽扯些无聊的事，她却把这些称为‘国家大事’。”传说有名医生还声称，中国最优秀的癌症专家提出的治疗方案没被采纳。</li>
<li>周恩来接受了这样一个事实，那就是，中国共产主义的活力将不得不由一个农民领袖来提供。这个人知道农民是如何生活的，并清楚他们在想些什么。而另一方面，毛泽东则需要一个能在世界上代表中国共产主义运动的外交家。周恩来并不奉承毛泽东，但他熟悉毛泽东的个性。毛泽东一方面不信任溜须拍马之辈，另一方面又对潜在的背叛十分敏感。周恩来能够熟练地平息这些不安全因素，而毛泽东为周恩来提供了一个坚如磐石般的长者形象，周恩来童年的经历或许已使他对这样一个形象十分向往。</li>
<li>不是周恩来低估了共产主义，而是毛泽东等走的太快，因为他们在目标与手段之间失去了平衡，他们贪心地以违背自然规律的速度去追求效果，准备把人性中最坏的部分引导出来，还着魔似的相信这可以达到好的目的。这不是共产主义，这只是一个壮观的带有孩子气的梦幻。只有周恩来才是真正的共产主义者，别的人只不过是在玩弄空头政治，而这是他所不擅长的，他有着经过改头换面的拿破仑式的博学，还带有梅特涅式的政治上的坚韧。</li>
<li>周恩来一生的事业可以用消极的色彩来描绘。他献身于共产主义事业，而它能否实现还是个问题；他后来发现，甚至在经济发展这类问题上，其精选出来的信条加上他自己那第一流的实干技巧也不能带来所希望的结果。他自己也在20世纪40年代就认识到除非千百万人民被成功地教育过来，把他们的思想改造得具有合作与集体主义精神，否则的话，共产主义在中国就不会起什么作用。但是，一旦他成为这个巨大国家的政府领导人，他就被驱使着为立即实现共产主义的所有目标而全速前进。</li>
<li>周恩来最后没能实现他的诺言，终其一生也没能把中国决定性地带入一个明显有着更高生活水平的更先进的工业和技术发展的现代社会。严格地说，这不是他的错，而更多的应归因于客观条件的无情。任何想在这样一个落后的大国迅速取得巨大进步的人都难免会遭到巨大挫折。然而，周恩来没有在这不可避免的挫折面前撒手不管或是作出过激的反应。他只是不动声色地坚守他的阵地，为使共产党中国的改革能继续下去提供唯一的一股主要动力。他这么做的时候，不像其他领导人那样以一种执拗的、决不通融的方式进行，而是以一种永远使人感到振奋的、非常民主的风格来进行，这就使得别人不断地集合在他的周围并帮助他奋力去实现目标。</li>
<li>苗谴责周为他的革命把少帅当成了牺牲品。 “不，苗兄，不是我的革命，是为了我们民族的命运，为了正在流血牺牲的千千万万个我们的同胞。你在少帅的舒适的司令部里待得太久了。你还没有亲自到川西、陕北，以及那么多无法生活的地方走走，你还没有看见我们的大多数人民是怎样生活的，他们祖祖辈辈都过着非人的生活啊！” 苗坚持说周对少帅没有感情。“我曾听说共产党人从不为自己同志的死而落泪。” “不！”周回答，“我们从不为悲哀落泪，我们只有愤怒的相，这是绝对不同的，我们正在为人民而战，感伤是没有用的。我们的革命经验是我们的同志用生命换来的，我们的政策是用鲜血写成的，靠几滴伤感的泪水是不行的。” </li>
<li>妇女权利是周恩来热忱改革的对象之一。他对上海的一个妇女组织说：“家庭是很重要的。你们不要看不起家务工作。不管怎么说，你们每个人都负责个一人政府。你们每个人都管理着你们家庭的内政部和外交部。还有谁的工作比这还重要？” </li>
<li>他们是一些错误地判断了人类本性的理想主义者。周恩来接着说，社会主义道路应该是一步一步地走，首先要教育群众，使他们达到一个公平社会的道德水平所要求的高度。在过渡时期，必须认识到群众仍是一些普通的人，他们中间有些人先进，有些人落后，因此“物质刺激”是必要的，鉴于那些一厢情愿的思想家曾经一度认为中国在十几年内就能跨入发达国家的行列，周恩来估计中国还将需要30~-40年才能做到资金和消费品的自给自足，而要达到西方那么高的生活水平，还需要差不多100年的时间。</li>
<li>一些国民党人想把他从共产党这里争取过去，“他们从来没有成功过，因为他从不在意个人的安逸、财富和势力”。</li>
<li>像以往一样，周恩来的策略是找出双方的理亏之处，迫使双方都作出使对方满意的让步。</li>
<li>“文化大革命”中所发生的事是如此复杂，使人们几乎不可能对它作一个简单的分析。但是，看清它的最好的方法是重新观察一下三个融合在一起的,性质截然不同而又都刻有“文革”标记的现象。首先，我们看到的是一场为改变大部分党员和非党员头脑中的传统观念以及封建主义和非社会主义 思想而进行的意识形态运动。这场运动的最终目标是使民主、社会主义和集体主义精神达到一个更高的水平，周恩来是这一愿望的拥护者。 后来，周恩来就是从这个意义出发，把“文革”解释为一个漫长过程 第一步，认为它“不可能一下子解决所有的问题”。几年后，他在与费利克斯・格林谈话时引述了毛的革命思想，并说道：“类似这样的革命应该一次又一次地进行，而且每一次都应达到一个更高的阶段，每一次都应比前一次更深入。”周恩来在这里并不是违心地讲话，而是以一个热心的社会主义者的身份讲这番话的。他在这里以他一的乐观主义态度假定下一次革命可以免无政府主义和权力斗争。 从高级领导层看，这场“文化大革命”也可算作一场夺权的斗争。在斗争中、毛泽东依靠他与周恩来和代表军队的林彪建立的强大联盟，从少奇手中新夺回了他的领导权。西方观察家一般都认为周恩来是一个温和派，但在这场特殊的斗争中，他与毛泽东站在起。这可能是因为他更信任、尊敬毛泽东。周恩来与他亲密地共同工作了35年，而刘少奇与周恩来却不太熟悉。 最后，还有一个低层次的“文化大革命”。这一革命发生在远离北京的地方。它打破正常的法律和秩序的限制，允许一些个人和派别进行报复活动权行动。这场革命最初像是一次有益的周期性放血，但最后却演变成 影全国性的混乱，于是周恩来转而坚决反对它并在最后取得了成功。 </li>
<li>他的一个崇拜者后来这样写道：“他甚至能与魔鬼共事，并从中获胜。 毛泽东开始把周恩来叫做“管家”，这是一个善意的称呼。有一个欧洲外交家曾经这样评论道：如果把中国比作一个家庭，那么，“深受人民喜爱的周恩来就扮演了一个母亲的角色，而一开始受人尊敬、后来又让人害怕的毛泽东则扮演了父亲的角色”。 一个美国学者在华盛顿举行的参议院听证会上警告说，不应过于乐观地把周恩来看做一个实用主义者和一个讲道理的人。“实际上”弗朗茨・迈克尔教授说他是一个很难对付的领导人，但迈克尔所代表的观点在美国舆论界的优势地位正在动摇。周恩来那过人的才能使他不仅在国内压倒了林彪和陈伯达，而且在国外也击败了那些反对他的人。</li>
</ul>
<p>同在《毛泽东传》中一样，作者把总理漫长一生的政治道路选择投射到其童年经历，企图追根溯源作出宿命论的诠释。真可笑。不过，算上文化的间隔，总体上还算客观。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yuanwanli1995.github.io/2021/10/19/2021-10-19-%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E4%BC%A0%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanwanli">
      <meta itemprop="description" content="等不是办法，干才有出路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="brisk">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/19/2021-10-19-%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E4%BC%A0%E3%80%8B/" class="post-title-link" itemprop="url">《毛泽东传》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-19T00:00:00+08:00">2021-10-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-19 18:50:15" itemprop="dateModified" datetime="2022-03-19T18:50:15+08:00">2022-03-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>迪克•威尔逊 </p>
<ul>
<li>如果老师的课枯燥乏味，他就看小说或打瞌睡——他后来解释说，这是对那些不会用提问和对话引起学生兴趣的老师的一种惩罚。</li>
<li>笔记中说：“我之界当扩而充之，是故宇宙一大我也。”毛指出古代的仁人志士“有杀身亡家而不悔者矣”。毛解释说，这样的人毒蛇螫手，他必断腕。 毛评论说：“彼仁人者，以天下万事为身，而以一身一家为腕，惟其爱天下万世之诚也，是以不敢爱其身家。身家虽死，天下万世固生，仁人之心安矣。”从毛自己写的这些话中可以明显地看出，毛就自己的行为对家庭的影响有一种社会犯罪感，可以看出，他是在为他后来抛弃自己的家庭进行辩护。从笔记中当然也看出毛的使命感。 毛在会上“从不轻易表态”，无论是主持会议还是一般发言——最突出的是他从不作冗长、离题而混乱的讲话。如果他旁边的其他人开始辩论，甚至吵起来的时候，毛都静静地用心倾听各方面的意见。 无论什么时候其他人谈话时，毛都“略低着头或偏着头听别人谈话，而自己只‘嗯’、‘是的’的回答，在倾听对方说完之后，他有条有理地给对谈者分析，提出要点，作出结论。他的话并不多，但每一句都很中肯，都能启发人。” 我过了20年甘露般的生活，对世界一无所知。——毛 他读了查尔斯·达尔文的《物种起源》、亚当斯密的《原富》、穆勒的《名学》、赫伯特·斯宾塞的《群学肆言》、孟德斯鸠的《法意》、让·雅克·卢梭的《社会契约论》以及赫胥黎的《天演论》。 毛在军营中的雇佣兵生活使他懂得，依靠这种军队来达到革命的目的是徒劳的，因为在政治上很难教育他们。毛明白，要成功地进行农村改革运动……就必须武装农民自己。</li>
<li>毛回忆说：“我的军饷是每月七元，每月伙食用去2元。我还得花钱买水。士兵用水必须到城外去挑，但是我是一个学生，不屑挑水，只好向挑夫买水。”毛年轻时很看重劳动的贵贱。 <strong>在大家争辩激烈时，从不轻易表态，等到大家意见发挥已尽，他才从容作出总结</strong>。他的总结总是取长舍短，斟酌尽善；对于一个问题，一种争论，总是分析深入，抓住要害。所以大家都心悦诚服。好些争论即因他精切简当的剖析而得到解决。 署名是“二十八画生启事”——“毛泽东”三个字共有二十八画。 毛反驳说：“如果领袖没有权利，就不可能执行计划，就不能得心应手。领袖拥有的权力多，事情就比较容易办。为了改造一个国家，国民必须刻苦自励，并且需要作出牺牲。” 毛说：“是的，压迫是政治的精髓。如果你压迫得法，说明你的政治是成功的。归根结底，政治的影响力十分简单，不过是经常保持压迫罢了。</li>
</ul>
<p>——争辩往往不能达成共识，除非两个人诚心讨论，这样的情况很少。不表态是更有效的做法。</p>
<ul>
<li>这时，拿未曾改造的知识分子同工人农民比较，就觉得知识分子不干净了，最干净的还是工人农民，尽管他们手是黑的，脚上有牛屎，还是比资产阶级和小资产阶级知识分子都干净。</li>
<li>919年的五四运动是北京自发产生的抗议内忧外患的学生运动，当时毛正在参观他自己国家的圣地——显然他从中汲取了营养。 得出结论认为失败的原因在于中国知识分子脱离广大人民群众。知识领袖要取得任何革命的胜利都必须密切联系这个国家的公民。 我并不想去欧洲。我觉得我对自己的国家还了解的不够，我把时间花在中国会更有益处。</li>
<li>毛清楚地记得在广州听孙讲话以及与他交谈的情景。毛说：“他是一个演说家，一个鼓动家，讲起话来雄辩有力，赢得了一片掌声——他不容别人与他争论，或提出他们自己的观点。实际上他的话<strong>水分很多，油很少</strong>。他不讲民主。</li>
<li>尽管当时工人运动处于低潮，毛任凭风浪起，稳坐钓鱼船。他完全从容自若，似乎一切都在安排之中。 若干年后毛回想起那些日子他进行农村调查的经历。他说，你不能仅下到村里去就希望能了解他们的结构和社会状况。我花了十几年功夫，才搞清楚。茶馆、赌场，什么人都接近、调查……我在家乡，找贫苦农民调查。 但毛也警告他的读者，不要人为地加速造反的行动。“菩萨是农民立起来的，到了一定时期农民会用他们的双手丢开这些菩萨，无需旁人过早地代庖丢菩萨。” 他有突出的军事素质，但缺乏政治判断力，当冲突的命令来自不同的政治司令部时，往往发生动摇。他的忠诚主要是依靠有毛和他在一起。</li>
<li>最初几天起义进行得很顺利，许多重要城镇落到了起义军手里。然而，长沙的工人并没有像毛所期望的那样，起来支持农民。当两支已脱离国民党的部队决定在他们之间开战后，力量单薄的起义军就面临内部火并的危险，于是，安源矿工差不多都被消灭了，毛的农军也中了埋伏。在起义爆发后的一个星期内，毛不得不放弃毫无希望的整个行动。正如他所承认的，“部队的纪律差，政治训练水平低，指战员中有许多动摇分子。开小差的很多。</li>
<li>毛忠告做领导工作的人，“迈开你的双脚，到你的工作范围的各部分各地方去走走，学个孔夫子的’每事问‘。’”“调查就像‘十月怀胎’，解决问题就像‘一朝分娩’。” 你对于某个问题没有调查，就停止你对于某个问题的发言权。——毛 林彪在古田支持了毛，但也许为进一步坚定他的信心，因而毛于1月5日给他写了一封信，题为《星星之火，可以燎原》。</li>
<li>另一个需要纠正的极端是绝对平均主义。“官长骑马，不认为是工作需要，而认为是不平等制度”。有些人要求分物品和背米一律平等：“司令部住了一间大点的房子也要骂起来。” 毛解释说：“就是在社会主义时期”，也“绝无所谓绝对的平均”。1930年元旦，红四军领导在古田举行会议，毛同意重新恢复政治部，牺牲了士兵苏维埃的权力。毛按会议精神对部队官兵进行了整顿，巩固了他的领导，因为类似苏维埃式的民主制度有可能给他的对手钻空子的机会。 他还建议加强党在军队中的作用，党支部由官兵混合组成。那些有“错误的政治倾向”的党员，那些只想大吃大喝、抽鸦片、赌博，或不惜犯罪去获取外币黄金发财又不思悔改的党员，应被从党内清除出去。 至于军队本身，毛建议军事指挥员和政治委员应该“共同的平等的”参与决策。他制定了详细的、新的、严格的纪律条例，要求官兵在党的政治口号下进行工作。 总之，他这样对待他的同志是有点过分的。林彪支持他，但彭德怀有意见。在井冈山周围游击了两年之后，毛的战地指挥员们对以江西的贫瘠农村为支撑红军的根据地，已有了显而易见的不满。从而更倾向于李立三路线，在城市地区振兴革命，现在听来就要比毛的路线更具有吸引力。指挥员们试图立即就移驻到城市去。毛使用整编打乱指挥的方式，才调换了许多高级指挥员。</li>
<li>他告诫说，民主应是集中指导下的民主。党的领导机关要有正确的指导路线，就必须“明了下级机关的情况和群众生活的情况，成为正确指导的客观基础”。决议不要太随便，一经形成，就必须坚决执行。“少数服从多数”，但是党内批评应该加强，必须认识到“党内批评是坚强党的组织、增加党的战斗力的武器……不应当利用批评去做攻击个人的工具”。 由于这样一些原因，革命的进程是缓慢的。“红军每到一地，群众冷冷清清，经过宣传之后，才慢慢地起来。”接下去从毛的笔下流露出的便是他一生中最具动摇和痛苦情绪的句子：“我们深深感觉寂寞，我们时刻盼望这种寂寞生活的终了。” 毛遭到监禁，第三次被从中央委员会中清除出去。由于在莫斯科的王明和在瑞金的博古的共同努力，此时，毛面临被永久排除出中国共产党高级领导层的前景。当听到他被监禁的消息后，一个后来脱党的老伙伴龚楚，带了一些酒和鸡看他，他们一边吃一边回忆上井冈山之前第一次会面的情形。日落后，他们又喝了很长时间，当他的朋友要回去时，毛打着手势说：“唉，井冈山同志的天下一去不复返了。” 两个星期后，长征开始了。</li>
<li>我郑重地向大会提出，我们应该深刻地注意群众生活的问题，从土地、劳动问题，到柴米油盐问题。……一切这些群众生活上的问题，都应该把它提到自己的议事日程上。应该讨论，应该决定，应该实行，应该检查。要使广大群众认识我们是代表他们的利益的，是和他们呼吸相通的。要使他们从这些事情出发，了解我们提出来的最高的任务，革命战争的任务，拥护革命，把革命推到全国去，接受我们的政治号召，为革命的胜利斗争到底。同志们，真正的铜墙铁壁是什么？是群众，是千百万真心实意地拥护革命的群众。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuanwanli</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
